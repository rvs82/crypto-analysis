<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="robots" content="noindex">
    <title>Crypto Trading</title>
    <style>
        body { font-family: 'Arial Narrow', Arial, sans-serif; margin: 20px; background-color: #f0f0f0; overflow-y: auto; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; background-color: white; }
        th, td { padding: 10px; border: 1px solid #ddd; text-align: center; font-size: 15px; }
        th { background-color: #4CAF50; color: white; }
        .long { color: green; }
        .short { color: red; }
        .neutral { color: black; }
        .market-flat { display: inline-block; width: 10px; height: 10px; border: 1px solid black; background-color: yellow; vertical-align: middle; margin-right: 5px; }
        .market-up { display: inline-block; width: 10px; height: 10px; border: 1px solid black; background-color: #90ee90; vertical-align: middle; margin-right: 5px; }
        .market-down { display: inline-block; width: 10px; height: 10px; border: 1px solid black; background-color: red; vertical-align: middle; margin-right: 5px; }
        .up { color: green; font-size: 18px; vertical-align: middle; margin-left: 5px; }
        .down { color: red; font-size: 18px; vertical-align: middle; margin-left: 5px; }
        .blink-green { animation: blinkGreen 2s infinite; }
        .blink-red { animation: blinkRed 2s infinite; }
        @keyframes blinkGreen {
            0% { background-color: white; }
            50% { background-color: rgba(0, 255, 0, 0.2); }
            100% { background-color: white; }
        }
        @keyframes blinkRed {
            0% { background-color: white; }
            50% { background-color: rgba(255, 0, 0, 0.2); }
            100% { background-color: white; }
        }
        #marketMood { width: 100%; height: 40px; display: flex; justify-content: space-between; align-items: center; color: white; font-size: 16px; transition: background 1s ease; }
        #marketMood .longs { flex: 1; text-align: left; padding-left: 10px; }
        #marketMood .shorts { flex: 1; text-align: right; padding-right: 10px; }
        #trade { margin-top: 20px; font-size: 15px; }
        #trade strong { font-weight: bold; }
        #reasoning, #stats { margin-top: 10px; font-size: 15px; }
        #stats { display: flex; align-items: center; }
        details { margin-top: 5px; width: 100%; }
        summary { cursor: pointer; }
        #recommendations { font-family: 'Arial Narrow', Arial, sans-serif; font-size: 14px; }
        #recommendations details { margin-bottom: 10px; }
        h2 { font-family: 'Arial Narrow', Arial, sans-serif; font-size: 18px; margin-bottom: 10px; }
        button { padding: 5px 10px; margin-left: 10px; }
        #channelExitCheckbox { margin-top: 20px; }
    </style>
</head>
<body>
    <div id="marketMood">
        <div class="longs">Лонги 0%</div>
        <div class="shorts">Шорты 0%</div>
    </div>
    <table>
        <thead>
            <tr>
                <th>Пара</th>
                <th>5м</th>
                <th>15м</th>
                <th>30м</th>
                <th>1ч</th>
                <th>4ч</th>
                <th>1д</th>
                <th>1н</th>
            </tr>
        </thead>
        <tbody id="data"></tbody>
    </table>
    <div id="trade"><strong>Сделка:</strong> Нет</div>
    <div id="reasoning"></div>
    <div id="stats"><strong>Статистика:</strong> Загрузка... <button onclick="resetStats()">Сбросить</button></div>
    <div id="recommendations"><h2>Рекомендации ИИ:</h2><br></div>
    <details>
        <summary><h2>Техническое задание</h2></summary>
        <div id="techSpec">
            <strong>Новый вариант (обновлено):</strong><br>
            Сайт использует индикатор Nadaraya-Watson Envelope [LuxAlgo] с режимом Repainting Smoothing, bandwidth 8, multiplier 3, данными закрытия на таймфреймах 5м, 15м, 30м, 1ч, 4ч, 1д, 1н. Обработка данных — обучаемый ИИ с учётом динамики рынка (Флет, Восходящий, Нисходящий), цен BTC и ETH (корреляция с валютами), уровней объёма (OBV), EMA 200/100/365/1460, Фибоначчи (0.5, 0.618 — ключевой), горизонтальных объёмов, поглощения свечей, длинных хвостов (интерес покупателей/продавцов). Данные в горизонтальной таблице с рекомендациями: "Нет" (чёрный), "Лонг" (зелёный), "Шорт" (красный), рядом вероятность успеха в % (целые числа 0–100, рассчитывает ИИ, обновляется плавно), направление рынка квадратиком: Флет (жёлтый), Восходящий (зелёный), Нисходящий (красный) и стрелка ↑ (зелёная)/↓ (красная) по последнему касанию границы Nadaraya (обновляется каждые 5 свечей). При касании или пробое верхней границы ячейка мигает слабым зелёным градиентом, нижней — слабым красным, до возврата в канал. Одновременно открыта 1 сделка размером 100 USDT. Поле "Сделка" показывает криптовалюту, таймфрейм, направление (цветное), вероятность успеха, цены открытия, стоп-лосс, тейк-профит (не 0 и не ниже, неизменны до закрытия). После "Статистика" — кнопка "Сбросить" в одном ряду для обнуления вручную. Сделки открываются при вероятности ≥ 50% с оптимальным RRR (ИИ), только если цена пробила уровни Nadaraya (выше верхней — "Шорт", ниже нижней — "Лонг"), пробой (ориентир 0.5%, зависит от OBV, Фибо, ситуации), с учётом OBV (рост для "Лонг", падение для "Шорт"), крупных покупок/продаж, скачков (>1% за свечу), ретестов (ликвидность с уровня), поглощения (бычье для "Лонг" с коррекцией до Фибо 0.5–0.618, дополнительный сигнал), EMA 200/100/365/1460 (поддержка/сопротивление с OBV), Фибоначчи, горизонтальных объёмов, корреляции с BTC/ETH (если LDO пробила границу, а BTC/ETH нет, ждём их отскока). Не открывать "Лонг" выше `nw.upper`, "Шорт" ниже `nw.lower`. Звуковые оповещения: галочка "Звук" (мелодичный колокольчик 5 секунд, разовый при выходе из канала для каждой валюты). Под сделкой — подробные рассуждения ИИ о причинах открытия или отсутствия сделки (рынок, OBV, EMA, Фибо, поглощение, BTC/ETH, хвосты).<br>
            ИИ учитывает направленность рынка:<br>
            - **Флет (жёлтый)**: "Лонг" при пробое нижней с ростом OBV, "Шорт" при пробое верхней с падением OBV — цена к середине.<br>
            - **Восходящий (зелёный)**: "Лонг" при пробое нижней с OBV и BTC/ETH, "Шорт" при пробое верхней с большим OBV.<br>
            - **Нисходящий (красный)**: "Шорт" при пробое верхней с падением OBV, "Лонг" при пробое нижней с OBV и BTC/ETH.<br>
            Накопление/консолидация (< 0.5% за 3 свечи) — шанс на разворот/скачок с OBV, учитывает интерес покупателей/продавцов (хвосты), коррекция или тренд по покупкам/продажам. ИИ ждёт чёткого пробоя (0.5% от уровня, не строго), избегает поспешных выводов, анализирует рынок и OBV перед сделкой. Идеал — торговля от границ до противоположной, но учитывает коррекции до Фибо (0.5, 0.618 — ключевой). Учитывает ретесты (ликвидность), середину канала (без сделок), корреляцию с BTC/ETH. ИИ обучается на истории сделок, снижая ошибки. Оптимизация для Render: обновление раз в 10 секунд, 500 свечей, минимум вычислений для бесплатного тарифа (512 МБ RAM, 0.1 CPU). Убраны лишние индикаторы (RSI, MACD, ADX), запросы и настроение рынка. Под статистикой — меню с рекомендациями, техзаданием, "Как работает сайт". Вертикальная прокрутка. Индексация сайта запрещена.<br><br>
            Рекомендации ИИ под статистикой для каждой валюты в выпадающих меню: краткий анализ текущего рынка, вероятность прибыльных сделок сейчас и в ближайшее время, чего ждать, прогноз **роста** (зелёный)/**падения** (красный), точка разворота (аргументация: Фибо, EMA, OBV, новости из CoinDesk, CoinTelegraph, Binance News), дополнения (данные ИИ).
        </div>
    </details>
    <details>
        <summary><h2>Как работает сайт</h2></summary>
        <div id="howItWorks">
            Этот сайт помогает трейдерам решать, покупать или продавать криптовалюты (LDOUSDT, AVAXUSDT, XLMUSDT, HBARUSDT, BATUSDT, AAVEUSDT), показывая сигналы для сделок и анализируя рынок. Вот как это работает:<br><br>
            <strong>Как формируются сигналы:</strong><br>
            Сайт использует индикатор Nadaraya-Watson Envelope — это как рамка вокруг цены, показывающая, где она обычно находится. У рамки есть верхняя граница (nw.upper), нижняя граница (nw.lower) и середина (smooth). Если цена уходит выше верхней границы примерно на 0.5%, это сигнал "Шорт" (продажа), потому что она может вернуться к середине. Если ниже нижней границы — "Лонг" (покупка), так как цена может пойти вверх. Но 0.5% — это не строго, ИИ смотрит по ситуации. Он проверяет, чтобы это был настоящий пробой, а не просто топтание у границы (накопление). Для этого ИИ смотрит объёмы (OBV): если они растут — больше покупателей, значит "Лонг", если падают — больше продавцов, значит "Шорт". Также он учитывает уровни EMA (200, 100, 365, 1460) — это как стены, от которых цена может отскочить, уровни Фибоначчи (0.5 и 0.618) — точки, куда цена часто приходит, и поглощение свечи — когда новая свеча полностью перекрывает старую, показывая силу покупателей или продавцов. Ещё ИИ смотрит, как двигаются BTC и ETH: если LDO пробила границу, а BTC ещё нет, LDO может идти дальше, пока BTC не отскочит. Длинные хвосты на свечах показывают, где покупатели или продавцы активно вмешиваются — это тоже сигнал.<br><br>
            <strong>Как открываются сделки:</strong><br>
            ИИ выбирает одну сделку с вероятностью успеха 50% или больше. Он считает эту вероятность, глядя на пробой границы, объёмы, EMA, Фибоначчи, поглощение и движение BTC с ETH. Сделка открывается только при пробое: выше верхней границы — "Шорт", ниже нижней — "Лонг", но не наоборот (нет "Лонг" выше верхней или "Шорт" ниже нижней). Размер сделки — 100 USDT. ИИ ставит стоп-лосс (где остановить убытки) и тейк-профит (где взять прибыль), и они не меняются, пока сделка не закроется. Сделка закрывается сама, если цена доходит до стоп-лосса (убыток) или тейк-профита (прибыль). В боковике (Флет, жёлтый квадратик) ИИ торгует от границ к середине, в росте (Восходящий, зелёный) чаще выбирает "Лонг", в падении (Нисходящий, красный) — "Шорт". ИИ учится на своих сделках: если прошлая закрылась в убыток, он осторожнее в следующий раз.<br><br>
            <strong>Как обрабатываются данные:</strong><br>
            Данные о ценах и объёмах сайт берёт с Binance через их API в реальном времени. Каждые 10 секунд он обновляет цены для всех валют и пересчитывает сигналы. ИИ смотрит последние 500 свечей (историю цен) для каждой валюты и каждого таймфрейма (5м, 15м, 30м, 1ч, 4ч, 1д, 1н). Он считает границы Nadaraya, проверяет объёмы, EMA, Фибоначчи, поглощение, корреляцию с BTC и ETH, хвосты свечей. ИИ не торопится: он ждёт чёткого пробоя, смотрит, чтобы не было топтания у границы, и учитывает, как ведут себя BTC и ETH, потому что они сильно влияют на рынок. Всё делает ИИ автоматически по заданным правилам, человек тут не вмешивается. ИИ учится на своих ошибках, чтобы не повторять их.<br><br>
            <strong>Что показывает сайт:</strong><br>
            Вверху — общий блок настроения рынка: "Лонги" (зелёный % слева) и "Шорты" (красный % справа) с плавным градиентом, данные из рекомендаций ИИ. В таблице для каждого таймфрейма: сигнал ("Лонг", "Шорт" или "Нет"), вероятность успеха (например, 70%), квадратик с рынком слева (жёлтый для Флет, зелёный для Восходящего, красный для Нисходящего) и стрелка справа (↑ зелёная или ↓ красная), показывающая, куда идёт цена от последней границы — вверх от нижней или вниз от верхней. Квадратики и стрелки обновляются раз в 5 свечей, чтобы не дёргаться. Если цена пробивает верхнюю границу, ячейка слегка мигает зелёным, нижнюю — красным, пока не вернётся в рамку, и звучит колокольчик 5 секунд один раз для валюты (если звук включён). Под таблицей — текущая сделка, её параметры и объяснение от ИИ. Далее — статистика с кнопкой "Сбросить", затем выпадающие меню: рекомендации ИИ для каждой валюты, техзадание и "Как работает сайт". Внизу — чекбокс "Звук". Сайт работает плавно и не перегружает бесплатный тариф Render.
        </div>
    </details>
    <div><input type="checkbox" id="channelExitCheckbox" checked> Звук</div>

    <script>
        const tbody = document.getElementById('data');
        const tradeDiv = document.getElementById('trade');
        const reasoningDiv = document.getElementById('reasoning');
        const statsDiv = document.getElementById('stats');
        const recommendationsDiv = document.getElementById('recommendations');
        const marketMood = document.getElementById('marketMood');
        let lastSignal = {};

        function updateData() {
            fetch('/data')
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
                    return response.json();
                })
                .then(data => {
                    tbody.innerHTML = '';
                    let recommendationsHtml = '<h2>Рекомендации ИИ:</h2><br>';
                    const symbols = ['LDOUSDT', 'AVAXUSDT', 'XLMUSDT', 'HBARUSDT', 'BATUSDT', 'AAVEUSDT'];
                    let totalLongs = 0;
                    let totalShorts = 0;
                    let totalRecommendations = 0;

                    for (const symbol of symbols) {
                        const rec = data.recommendations[symbol] || {};
                        const trade = data.trades[symbol] || { active: null, openCount: 0, closedCount: 0, stopCount: 0, profitCount: 0, totalProfit: 0, totalLoss: 0 };
                        const row = document.createElement('tr');
                        recommendationsHtml += `<details open><summary>${symbol}</summary>`;
                        row.innerHTML = `
                            <td>${symbol}</td>
                            ${TIMEFRAMES.map(tf => {
                                const r = rec[tf] || { direction: 'Нет', confidence: 0, market: 'Флет', trend: 'none', pivot: lastPrices[symbol], reasoning: 'Нет данных', forecast: 'падение', outsideChannel: false, blinkDirection: '' };
                                const cls = r.direction === 'Лонг' ? 'long' : r.direction === 'Шорт' ? 'short' : 'neutral';
                                const marketCls = r.market === 'Флет' ? 'market-flat' : r.market === 'Восходящий' ? 'market-up' : 'market-down';
                                const trendArrow = r.trend === 'up' ? '↑' : r.trend === 'down' ? '↓' : '';
                                const blinkCls = r.outsideChannel ? `blink-${r.blinkDirection}` : '';
                                const signalKey = `${symbol}-${r.outsideChannel}`;
                                if (r.outsideChannel && lastSignal[signalKey] !== true && document.getElementById('channelExitCheckbox').checked) {
                                    const audio = new Audio('https://freesound.org/data/previews/339/339810_5121236-lq.mp3'); // 5-секундный колокольчик
                                    audio.play().catch(() => console.log(`Колокольчик для ${symbol} не воспроизведён`));
                                    lastSignal[signalKey] = true;
                                } else if (!r.outsideChannel) {
                                    lastSignal[signalKey] = false;
                                }
                                recommendationsHtml += `${tf}: прогноз: <span class="${r.forecast === 'рост' ? 'up' : 'down'}">${r.forecast}</span>, разворот: ${r.pivot.toFixed(4)} (${r.reasoning.split('.')[1] || 'нет данных'}), ${r.reasoning.split('.')[2] || ''}<br>`;
                                if (r.direction === 'Лонг') {
                                    totalLongs += r.confidence;
                                    totalRecommendations++;
                                } else if (r.direction === 'Шорт') {
                                    totalShorts += r.confidence;
                                    totalRecommendations++;
                                }
                                return `<td class="${cls} ${blinkCls}"><span class="${marketCls}"></span>${r.direction}${r.confidence > 0 ? ` ${r.confidence}%` : ''}<span class="${r.trend === 'up' ? 'up' : 'down'}">${trendArrow}</span></td>`;
                            }).join('')}
                        `;
                        recommendationsHtml += `</details>`;
                        tbody.appendChild(row);

                        if (trade.active) {
                            const cls = trade.active.direction === 'Лонг' ? 'long' : 'short';
                            tradeDiv.innerHTML = `<strong>Сделка:</strong> ${symbol} (${trade.active.timeframe}) <span class="${cls}">${trade.active.direction}</span> (${rec[trade.active.timeframe]?.confidence || 0}%), Открытие: ${trade.active.entry.toFixed(4)}, Стоп: ${trade.active.stopLoss.toFixed(4)}, Профит: ${trade.active.takeProfit.toFixed(4)}`;
                            reasoningDiv.innerHTML = `<strong>Рассуждения ИИ:</strong> ${rec[trade.active.timeframe]?.reasoning || 'Нет данных'}`;
                        } else {
                            tradeDiv.innerHTML = '<strong>Сделка:</strong> Нет';
                            reasoningDiv.innerHTML = `<strong>Рассуждения ИИ:</strong> Нет активных сделок, рынок анализируется.`;
                        }
                        statsDiv.innerHTML = `<strong>Статистика:</strong> Открыто: ${trade.openCount}, Закрыто: ${trade.closedCount}, Стоп: ${trade.stopCount}, Профит: ${trade.profitCount}, Прибыль: ${trade.totalProfit.toFixed(2)} USDT, Убыток: ${trade.totalLoss.toFixed(2)} USDT <button onclick="resetStats()">Сбросить</button>`;
                    }

                    const longPercent = totalRecommendations > 0 ? Math.round(totalLongs / totalRecommendations) : 0;
                    const shortPercent = totalRecommendations > 0 ? Math.round(totalShorts / totalRecommendations) : 0;
                    marketMood.style.background = `linear-gradient(to right, green ${longPercent}%, red ${longPercent}%)`;
                    marketMood.querySelector('.longs').textContent = `Лонги ${longPercent}%`;
                    marketMood.querySelector('.shorts').textContent = `Шорты ${shortPercent}%`;

                    recommendationsDiv.innerHTML = recommendationsHtml || '<h2>Рекомендации ИИ:</h2> Нет данных';
                })
                .catch(error => {
                    console.error('Ошибка получения данных:', error.message, error.stack);
                    tbody.innerHTML = TIMEFRAMES.map(tf => `<tr><td colspan="${TIMEFRAMES.length + 1}">Ошибка загрузки данных: ${error.message}</td></tr>`).join('');
                    recommendationsDiv.innerHTML = `<h2>Рекомендации ИИ:</h2> Ошибка загрузки: ${error.message}`;
                });
        }

        function resetStats() {
            fetch('/reset-stats', { method: 'POST' })
                .then(() => updateData())
                .catch(error => console.error('Ошибка сброса статистики:', error));
        }

        const TIMEFRAMES = ['5m', '15m', '30m', '1h', '4h', '1d', '1w'];
        updateData();
        setInterval(updateData, 10000);
    </script>
</body>
</html>
